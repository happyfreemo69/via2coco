#!/usr/bin/node
//takes the project.json generated by via and convert it to coco
var fs = require('fs');
var optimist = require('yargs')
    .usage('$0: node app -i vggproject.json -o folder')
    .options('i', {
        alias : 'input',
        describe: 'json generated by vggvia'
    })
    .options('o', {
        alias : 'output',
        describe: 'will create the coco like dataset in given folder. Default /tmp/coco',
        default: '/tmp/generated_coco'
    })
    .options('r', {
        alias : 'ratio',
        describe: 'ratio training/validation'
    })
    .demand(['input'])

var argv = optimist.argv;
if(argv.help){
    optimist.showHelp()
    process.exit(0);
}

var { promisify } = require('util');
var input = argv.input;
var output = argv.output;

/**
 * [makeTree description]
 * @param  {output:String} opts [description]
 * @return {[type]}      [description]
 */
function makeTree(opts){
    var mkdirp = require('mkdirp');
    function pmkdirp(s){
        return new Promise(function(resolve, reject){
            return mkdirp(s, function(err){
                if(err){
                    return reject(err);
                }
                return resolve();
            })
        })
    }
    return pmkdirp(opts.output).then(_=>{
        return Promise.all([
            pmkdirp(opts.output+'/coco/annotations'),
            pmkdirp(opts.output+'/coco/coco_train2014'),
            pmkdirp(opts.output+'/coco/coco_val2014')
        ])
    })
}


function writeAnnotations(fname, json){
    json.info = {
        description:"fill me",
        url:"fill me",
        version:"0.0.0",
        year:2018,
        contributor:process.env.USER,
        date_created:new Date
    };
    json.licenses = [
        {
            id:1,
            name:"fill me",
            url:"fill me"
        }
    ];
    return new Promise(function(resolve, reject){
        fs.writeFile(fname, JSON.stringify(json,null,1), function(err){
            if(err)return reject(err);
            return resolve();
        });  
    })
}

var sizeOf = promisify(require('image-size'));
function extractSize(fname){
    return sizeOf(fname);
}

function copyImage(inPath, outPath){
    return new Promise(function(resolve, reject){
        var inStream = fs.createReadStream(inPath);
        var outStream = fs.createWriteStream(outPath);
        inStream.pipe(outStream);
        inStream.on('error', reject);
        outStream.on('error', reject);
        inStream.on('end', function(){
            return resolve();
        });
    })
}

function computeArea(xs, ys){
    var area = require('area-polygon');
    return area(xs.map((x,i)=>{
        return [x, ys[i]]
    }));
}
function bboxFrom(xs, ys){
    var mx = Math.min(...xs);
    var Mx = Math.max(...xs);
    var my = Math.min(...ys);
    var My = Math.max(...ys);
    return [mx, my, Mx-mx, My-my]
}

/**
 * [extractAnnotations description]
 * @param  {[type]} img       [description]
 * @param  {str:id} categPool [description]
 * @return {[type]}           [description]
 */
function extractAnnotations(img, categPool, ctx){
    function createAnno(k,subK, area, bbox, pol){
        return {
            id:ctx.annoId++,
            image_id: img.id,
            category_id:categPool[k+'.'+subK],
            iscrowd:0,
            area: area,
            bbox: bbox,
            segmentation:[pol],
            width: img.w,
            height: img.h
        }
    }
    //'{"id":1,"image_id":1,"category_id":2,"iscrowd":0,"area":1517,"bbox":[71,51,45,45],
    //"segmentation":[[93,95.5,77.5,89,70.5,73,76.5,58,93,50.5,109,57.5,115.5,73,109.5,88,93,95.5]],"width":128,"height":128}
    var annos = [];
    img.regions.forEach((r,i)=>{
        if(r.shape_attributes.name == 'ellipse'){
            console.log('Ellipse not (yet) handled for '+img.filename);
            return;
        }
        var xs, ys;
        if(r.shape_attributes.name == 'rect'){
            let rs = r.shape_attributes; 
            let [rsx, rsy, rsw, rsh] = [rs.x, rs.y, rs.width, rs.height];
            xs = [rsx, rsx+rsw, rsx+rsw, rsx];
            ys = [rsy, rsy, rsy+rsh, rsy+rsh];
        }else{
            xs = r.shape_attributes.all_points_x;
            ys = r.shape_attributes.all_points_y;
        }
        if(!xs || !ys){
            throw 'no coordinate but shape found'+JSON.stringify(r.shape_attributes);
        }
        var pol  = xs.reduce((acc,x,i)=>{
            acc.push(x);
            acc.push(ys[i]);
            return acc;
        },[]);

        var bbox = bboxFrom(xs, ys);
        var area = computeArea(xs, ys);

        Object.keys(r.region_attributes).forEach(k=>{
            var attr = r.region_attributes[k];
            if(typeof(attr)=='object'){
                return Object.keys(r.region_attributes[k]).forEach(subK=>{
                    annos.push(createAnno(k, subK, area, bbox, pol))
                })
            }else{
//                console.log('ALL PANEL AS CP1')
//                attr = 'cp1';
                annos.push(createAnno(k, attr, area, bbox, pol))
            }
        })
    });
    return Promise.resolve(annos);
}

function buildCategPool(json){
    var dic = {};
    var z = 0;
    Object.keys(json._via_attributes.region).forEach(k=>{
        var master = json._via_attributes.region[k];
        if(master.type == 'checkbox'){
            Object.keys(master.options).forEach(subK=>{
                dic[k+'.'+subK] = z++;
            })
        }else if(master.type == 'radio'){
            Object.keys(master.options).forEach(subK=>{
                dic[k+'.'+subK] = z++;
            })
        }else if(master.type == 'dropdown'){
            Object.keys(master.options).forEach(subK=>{
                dic[k+'.'+subK] = z++;
            })
        }else{
            console.log('master : ', master)
            throw 'subattribute type not handled';
        }
    });
    return dic;
}
/**
 * copies the files linked from input
 * generate annotatedjson in coco like format
 * @param  {output:string, ratio:Number} opts ratio: default:0.7
 * @return {[type]}      [description]
 */
function processJson(opts){
    var outJsons = [{images:[], annotations:[]},{images:[], annotations:[]}];
    var json = require(opts.input);
    var categPool = buildCategPool(json);
    var bulker = require('nodelibs').bulker;
    var z = 0;
    var ctx = {annoId:0}
    //for all img
    return bulker.bulkIt(Object.keys(json._via_img_metadata), 10, function(k){
        var img = json._via_img_metadata[k];
        img.id = z++;
        //{"filename":"xx.jpg","size":9412,"regions":[{"shape_attributes":{"name":"polygon","all_points_x":[24,113,102,7],"all_points_y":[25,65,79,54]},"region_attributes":{"type":{"plaque":true}}}],"file_attributes":{}}
        img.datasetIdx = Math.random()<(opts.ratio && !Math.isNaN(opts.ratio) && parseFloat(opts.ratio) || 0.7)?0:1;
        img.outname = opts.output+'/coco/'+(img.datasetIdx == 0?'coco_train2014':'coco_val2014')+'/'+img.filename;

        return Promise.all([
            //enhance w, h
            extractSize(json._via_settings.core.default_filepath+'/'+img.filename).then(({width, height})=>{
                img.w = width;
                img.h = height;
            }).then(_=>{
                return extractAnnotations(img, categPool, ctx).then(cocoAnnos=>{
                    img.annotations = cocoAnnos;
                });
            }),
            copyImage(json._via_settings.core.default_filepath+img.filename, img.outname)
        ]).then(_=>{
            var now = new Date;
            var out = outJsons[img.datasetIdx];
            //'{"id":1,"file_name":"1346.jpeg","width":128,"height":128,"date_captured":"2018-04-13 03:25:06.134240","license":1,"coco_url":"","flickr_url":""}'
            out.images.push({
                id: img.id,
                file_name: img.filename,
                width: img.w,
                height: img.h,
                date_captured: now, 
                license:1
            }),
            img.annotations.forEach(anno=>{
                out.annotations.push(anno);
            })
        }).catch(e=>{
            console.log('failed ', e, e.stack, 'continuing....');
        })
    }).then(_=>{
        var categories = Object.keys(categPool).map(k=>{
            var id = categPool[k];
            var [master, sub] = k.split('.');
            return {
                id:id,
                name: sub,
                supercategory: master
            }
        })
        outJsons.forEach(out=>{
            out.categories = categories
        })
        //write json
        return Promise.all([
            writeAnnotations(opts.output+'/coco/annotations/instances_train2014.json', outJsons[0]),
            writeAnnotations(opts.output+'/coco/annotations/instances_val2014.json', outJsons[1]),
        ])
    })
}


function run(opts){
    return makeTree(opts).then(_=>{
        return processJson(opts);
    }).then(_=>{
        console.log('written to '+opts.output)
    })
}


run({output:output, input:input}).catch(e=>{
    console.log('e', e);
    throw e;
})